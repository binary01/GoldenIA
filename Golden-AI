class EnhancedGoldenAI:
    def __init__(self, base_model, task_complexity=0.5):
        self.W0 = base_model.weights  # المعرفة الأساسية
        self.phi = 1.618 * (1 + 0.1 * task_complexity)
        self.n_min = 1.0 / (self.phi - 1) if self.phi > 1 else 1.0
        self.n_max = 1000 * self.n_min
        
    def compute_alpha(self, n):
        if n <= self.n_min:
            return 1.0
        elif n >= self.n_max:
            return self.phi + 0.05
        else:
            return (1 + self.phi * n) / n
    
    def golden_update(self, W_current, grad, n_samples, lr, epoch):
        alpha = self.compute_alpha(n_samples)
        
        # المكون الذهبي
        W_golden = alpha * self.W0 + (1 - alpha) * W_current
        
        # معامل التدرج الزمني
        lambda_t = 0.1 * math.exp(-0.01 * epoch)
        
        # التحديث النهائي
        W_new = (1 - lambda_t) * W_golden + lambda_t * (W_current - lr * grad)
        
        return W_new
    
    def compute_loss(self, y_pred, y_true, W_current, n_samples):
        alpha = self.compute_alpha(n_samples)
        
        # فقدان البيانات
        L_data = F.cross_entropy(y_pred, y_true)
        
        # فقدان المعرفة السابقة
        L_prior = F.mse_loss(W_current, self.W0)
        
        # فقدان التوازن
        balance_penalty = 0.0
        if alpha < 0.3 or alpha > 0.7:
            balance_penalty = ((alpha - 0.5) / 0.5) ** 2
        
        # فقدان المرونة
        L_elastic = 0.001 * torch.norm(W_current - self.W0, p=1) + \
                   0.0001 * torch.norm(W_current - self.W0, p=2)**2
        
        return alpha * L_prior + (1 - alpha) * L_data + 0.1 * balance_penalty + L_elastic
